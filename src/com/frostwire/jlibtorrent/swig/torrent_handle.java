/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.frostwire.jlibtorrent.swig;

public class torrent_handle {
  private long swigCPtr;
  protected boolean swigCMemOwn;

  protected torrent_handle(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(torrent_handle obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        libtorrent_jni.delete_torrent_handle(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  public torrent_handle() {
    this(libtorrent_jni.new_torrent_handle(), true);
  }

  public void add_piece(int piece, String data, int flags) {
    libtorrent_jni.torrent_handle_add_piece__SWIG_0(swigCPtr, this, piece, data, flags);
  }

  public void add_piece(int piece, String data) {
    libtorrent_jni.torrent_handle_add_piece__SWIG_1(swigCPtr, this, piece, data);
  }

  public void read_piece(int piece) {
    libtorrent_jni.torrent_handle_read_piece(swigCPtr, this, piece);
  }

  public boolean have_piece(int piece) {
    return libtorrent_jni.torrent_handle_have_piece(swigCPtr, this, piece);
  }

  public void get_full_peer_list(peer_list_entry_vector v) {
    libtorrent_jni.torrent_handle_get_full_peer_list(swigCPtr, this, peer_list_entry_vector.getCPtr(v), v);
  }

  public void get_peer_info(peer_info_vector v) {
    libtorrent_jni.torrent_handle_get_peer_info(swigCPtr, this, peer_info_vector.getCPtr(v), v);
  }

  public torrent_status status(long flags) {
    return new torrent_status(libtorrent_jni.torrent_handle_status__SWIG_0(swigCPtr, this, flags), true);
  }

  public torrent_status status() {
    return new torrent_status(libtorrent_jni.torrent_handle_status__SWIG_1(swigCPtr, this), true);
  }

  public void get_download_queue(partial_piece_info_vector queue) {
    libtorrent_jni.torrent_handle_get_download_queue(swigCPtr, this, partial_piece_info_vector.getCPtr(queue), queue);
  }

  public void set_piece_deadline(int index, int deadline, int flags) {
    libtorrent_jni.torrent_handle_set_piece_deadline__SWIG_0(swigCPtr, this, index, deadline, flags);
  }

  public void set_piece_deadline(int index, int deadline) {
    libtorrent_jni.torrent_handle_set_piece_deadline__SWIG_1(swigCPtr, this, index, deadline);
  }

  public void reset_piece_deadline(int index) {
    libtorrent_jni.torrent_handle_reset_piece_deadline(swigCPtr, this, index);
  }

  public void clear_piece_deadlines() {
    libtorrent_jni.torrent_handle_clear_piece_deadlines(swigCPtr, this);
  }

  public void set_priority(int prio) {
    libtorrent_jni.torrent_handle_set_priority(swigCPtr, this, prio);
  }

  public void file_progress(int64_vector progress, int flags) {
    libtorrent_jni.torrent_handle_file_progress__SWIG_0(swigCPtr, this, int64_vector.getCPtr(progress), progress, flags);
  }

  public void file_progress(int64_vector progress) {
    libtorrent_jni.torrent_handle_file_progress__SWIG_1(swigCPtr, this, int64_vector.getCPtr(progress), progress);
  }

  public void clear_error() {
    libtorrent_jni.torrent_handle_clear_error(swigCPtr, this);
  }

  public announce_entry_vector trackers() {
    return new announce_entry_vector(libtorrent_jni.torrent_handle_trackers(swigCPtr, this), true);
  }

  public void replace_trackers(announce_entry_vector arg0) {
    libtorrent_jni.torrent_handle_replace_trackers(swigCPtr, this, announce_entry_vector.getCPtr(arg0), arg0);
  }

  public void add_tracker(announce_entry arg0) {
    libtorrent_jni.torrent_handle_add_tracker(swigCPtr, this, announce_entry.getCPtr(arg0), arg0);
  }

  public void add_url_seed(String url) {
    libtorrent_jni.torrent_handle_add_url_seed(swigCPtr, this, url);
  }

  public void remove_url_seed(String url) {
    libtorrent_jni.torrent_handle_remove_url_seed(swigCPtr, this, url);
  }

  public void add_http_seed(String url) {
    libtorrent_jni.torrent_handle_add_http_seed(swigCPtr, this, url);
  }

  public void remove_http_seed(String url) {
    libtorrent_jni.torrent_handle_remove_http_seed(swigCPtr, this, url);
  }

  public boolean set_metadata(String metadata, int size) {
    return libtorrent_jni.torrent_handle_set_metadata(swigCPtr, this, metadata, size);
  }

  public boolean is_valid() {
    return libtorrent_jni.torrent_handle_is_valid(swigCPtr, this);
  }

  public void pause(int flags) {
    libtorrent_jni.torrent_handle_pause__SWIG_0(swigCPtr, this, flags);
  }

  public void pause() {
    libtorrent_jni.torrent_handle_pause__SWIG_1(swigCPtr, this);
  }

  public void resume() {
    libtorrent_jni.torrent_handle_resume(swigCPtr, this);
  }

  public void set_upload_mode(boolean b) {
    libtorrent_jni.torrent_handle_set_upload_mode(swigCPtr, this, b);
  }

  public void set_share_mode(boolean b) {
    libtorrent_jni.torrent_handle_set_share_mode(swigCPtr, this, b);
  }

  public void flush_cache() {
    libtorrent_jni.torrent_handle_flush_cache(swigCPtr, this);
  }

  public void apply_ip_filter(boolean b) {
    libtorrent_jni.torrent_handle_apply_ip_filter(swigCPtr, this, b);
  }

  public void force_recheck() {
    libtorrent_jni.torrent_handle_force_recheck(swigCPtr, this);
  }

  public void save_resume_data(int flags) {
    libtorrent_jni.torrent_handle_save_resume_data__SWIG_0(swigCPtr, this, flags);
  }

  public void save_resume_data() {
    libtorrent_jni.torrent_handle_save_resume_data__SWIG_1(swigCPtr, this);
  }

  public boolean need_save_resume_data() {
    return libtorrent_jni.torrent_handle_need_save_resume_data(swigCPtr, this);
  }

  public void auto_managed(boolean m) {
    libtorrent_jni.torrent_handle_auto_managed(swigCPtr, this, m);
  }

  public int queue_position() {
    return libtorrent_jni.torrent_handle_queue_position(swigCPtr, this);
  }

  public void queue_position_up() {
    libtorrent_jni.torrent_handle_queue_position_up(swigCPtr, this);
  }

  public void queue_position_down() {
    libtorrent_jni.torrent_handle_queue_position_down(swigCPtr, this);
  }

  public void queue_position_top() {
    libtorrent_jni.torrent_handle_queue_position_top(swigCPtr, this);
  }

  public void queue_position_bottom() {
    libtorrent_jni.torrent_handle_queue_position_bottom(swigCPtr, this);
  }

  public void resolve_countries(boolean r) {
    libtorrent_jni.torrent_handle_resolve_countries__SWIG_0(swigCPtr, this, r);
  }

  public boolean resolve_countries() {
    return libtorrent_jni.torrent_handle_resolve_countries__SWIG_1(swigCPtr, this);
  }

  public void set_ssl_certificate(String certificate, String private_key, String dh_params, String passphrase) {
    libtorrent_jni.torrent_handle_set_ssl_certificate__SWIG_0(swigCPtr, this, certificate, private_key, dh_params, passphrase);
  }

  public void set_ssl_certificate(String certificate, String private_key, String dh_params) {
    libtorrent_jni.torrent_handle_set_ssl_certificate__SWIG_1(swigCPtr, this, certificate, private_key, dh_params);
  }

  public void set_ssl_certificate_buffer(String certificate, String private_key, String dh_params) {
    libtorrent_jni.torrent_handle_set_ssl_certificate_buffer(swigCPtr, this, certificate, private_key, dh_params);
  }

  public torrent_info torrent_file() {
    long cPtr = libtorrent_jni.torrent_handle_torrent_file(swigCPtr, this);
    return (cPtr == 0) ? null : new torrent_info(cPtr, true);
  }

  public void use_interface(String net_interface) {
    libtorrent_jni.torrent_handle_use_interface(swigCPtr, this, net_interface);
  }

  public void piece_availability(int_vector avail) {
    libtorrent_jni.torrent_handle_piece_availability(swigCPtr, this, int_vector.getCPtr(avail), avail);
  }

  public void piece_priority(int index, int priority) {
    libtorrent_jni.torrent_handle_piece_priority__SWIG_0(swigCPtr, this, index, priority);
  }

  public int piece_priority(int index) {
    return libtorrent_jni.torrent_handle_piece_priority__SWIG_1(swigCPtr, this, index);
  }

  public void prioritize_pieces(int_vector pieces) {
    libtorrent_jni.torrent_handle_prioritize_pieces(swigCPtr, this, int_vector.getCPtr(pieces), pieces);
  }

  public int_vector piece_priorities() {
    return new int_vector(libtorrent_jni.torrent_handle_piece_priorities(swigCPtr, this), true);
  }

  public void file_priority(int index, int priority) {
    libtorrent_jni.torrent_handle_file_priority__SWIG_0(swigCPtr, this, index, priority);
  }

  public int file_priority(int index) {
    return libtorrent_jni.torrent_handle_file_priority__SWIG_1(swigCPtr, this, index);
  }

  public void prioritize_files(int_vector files) {
    libtorrent_jni.torrent_handle_prioritize_files(swigCPtr, this, int_vector.getCPtr(files), files);
  }

  public int_vector file_priorities() {
    return new int_vector(libtorrent_jni.torrent_handle_file_priorities(swigCPtr, this), true);
  }

  public void force_reannounce(int seconds, int tracker_index) {
    libtorrent_jni.torrent_handle_force_reannounce__SWIG_0(swigCPtr, this, seconds, tracker_index);
  }

  public void force_reannounce(int seconds) {
    libtorrent_jni.torrent_handle_force_reannounce__SWIG_1(swigCPtr, this, seconds);
  }

  public void force_reannounce() {
    libtorrent_jni.torrent_handle_force_reannounce__SWIG_2(swigCPtr, this);
  }

  public void force_dht_announce() {
    libtorrent_jni.torrent_handle_force_dht_announce(swigCPtr, this);
  }

  public void scrape_tracker() {
    libtorrent_jni.torrent_handle_scrape_tracker(swigCPtr, this);
  }

  public void set_upload_limit(int limit) {
    libtorrent_jni.torrent_handle_set_upload_limit(swigCPtr, this, limit);
  }

  public int upload_limit() {
    return libtorrent_jni.torrent_handle_upload_limit(swigCPtr, this);
  }

  public void set_download_limit(int limit) {
    libtorrent_jni.torrent_handle_set_download_limit(swigCPtr, this, limit);
  }

  public int download_limit() {
    return libtorrent_jni.torrent_handle_download_limit(swigCPtr, this);
  }

  public void set_sequential_download(boolean sd) {
    libtorrent_jni.torrent_handle_set_sequential_download(swigCPtr, this, sd);
  }

  public void connect_peer(tcp_endpoint adr, int source) {
    libtorrent_jni.torrent_handle_connect_peer__SWIG_0(swigCPtr, this, tcp_endpoint.getCPtr(adr), adr, source);
  }

  public void connect_peer(tcp_endpoint adr) {
    libtorrent_jni.torrent_handle_connect_peer__SWIG_1(swigCPtr, this, tcp_endpoint.getCPtr(adr), adr);
  }

  public void set_max_uploads(int max_uploads) {
    libtorrent_jni.torrent_handle_set_max_uploads(swigCPtr, this, max_uploads);
  }

  public int max_uploads() {
    return libtorrent_jni.torrent_handle_max_uploads(swigCPtr, this);
  }

  public void set_max_connections(int max_connections) {
    libtorrent_jni.torrent_handle_set_max_connections(swigCPtr, this, max_connections);
  }

  public int max_connections() {
    return libtorrent_jni.torrent_handle_max_connections(swigCPtr, this);
  }

  public void set_tracker_login(String name, String password) {
    libtorrent_jni.torrent_handle_set_tracker_login(swigCPtr, this, name, password);
  }

  public void move_storage(String save_path, int flags) {
    libtorrent_jni.torrent_handle_move_storage__SWIG_0(swigCPtr, this, save_path, flags);
  }

  public void move_storage(String save_path) {
    libtorrent_jni.torrent_handle_move_storage__SWIG_1(swigCPtr, this, save_path);
  }

  public void rename_file(int index, String new_name) {
    libtorrent_jni.torrent_handle_rename_file(swigCPtr, this, index, new_name);
  }

  public void super_seeding(boolean on) {
    libtorrent_jni.torrent_handle_super_seeding(swigCPtr, this, on);
  }

  public sha1_hash info_hash() {
    return new sha1_hash(libtorrent_jni.torrent_handle_info_hash(swigCPtr, this), true);
  }

  public boolean op_eq(torrent_handle h) {
    return libtorrent_jni.torrent_handle_op_eq(swigCPtr, this, torrent_handle.getCPtr(h), h);
  }

  public boolean op_neq(torrent_handle h) {
    return libtorrent_jni.torrent_handle_op_neq(swigCPtr, this, torrent_handle.getCPtr(h), h);
  }

  public boolean op_lt(torrent_handle h) {
    return libtorrent_jni.torrent_handle_op_lt(swigCPtr, this, torrent_handle.getCPtr(h), h);
  }

  public enum flags_t {
    overwrite_existing(libtorrent_jni.torrent_handle_overwrite_existing_get());

    public final int swigValue() {
      return swigValue;
    }

    public static flags_t swigToEnum(int swigValue) {
      flags_t[] swigValues = flags_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (flags_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + flags_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private flags_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private flags_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private flags_t(flags_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public enum status_flags_t {
    query_distributed_copies(libtorrent_jni.torrent_handle_query_distributed_copies_get()),
    query_accurate_download_counters(libtorrent_jni.torrent_handle_query_accurate_download_counters_get()),
    query_last_seen_complete(libtorrent_jni.torrent_handle_query_last_seen_complete_get()),
    query_pieces(libtorrent_jni.torrent_handle_query_pieces_get()),
    query_verified_pieces(libtorrent_jni.torrent_handle_query_verified_pieces_get()),
    query_torrent_file(libtorrent_jni.torrent_handle_query_torrent_file_get()),
    query_name(libtorrent_jni.torrent_handle_query_name_get()),
    query_save_path(libtorrent_jni.torrent_handle_query_save_path_get());

    public final int swigValue() {
      return swigValue;
    }

    public static status_flags_t swigToEnum(int swigValue) {
      status_flags_t[] swigValues = status_flags_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (status_flags_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + status_flags_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private status_flags_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private status_flags_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private status_flags_t(status_flags_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public enum deadline_flags {
    alert_when_available(libtorrent_jni.torrent_handle_alert_when_available_get());

    public final int swigValue() {
      return swigValue;
    }

    public static deadline_flags swigToEnum(int swigValue) {
      deadline_flags[] swigValues = deadline_flags.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (deadline_flags swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + deadline_flags.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private deadline_flags() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private deadline_flags(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private deadline_flags(deadline_flags swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public enum file_progress_flags_t {
    piece_granularity(libtorrent_jni.torrent_handle_piece_granularity_get());

    public final int swigValue() {
      return swigValue;
    }

    public static file_progress_flags_t swigToEnum(int swigValue) {
      file_progress_flags_t[] swigValues = file_progress_flags_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (file_progress_flags_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + file_progress_flags_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private file_progress_flags_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private file_progress_flags_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private file_progress_flags_t(file_progress_flags_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public enum pause_flags_t {
    graceful_pause(libtorrent_jni.torrent_handle_graceful_pause_get());

    public final int swigValue() {
      return swigValue;
    }

    public static pause_flags_t swigToEnum(int swigValue) {
      pause_flags_t[] swigValues = pause_flags_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (pause_flags_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + pause_flags_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private pause_flags_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private pause_flags_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private pause_flags_t(pause_flags_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  public enum save_resume_flags_t {
    flush_disk_cache(libtorrent_jni.torrent_handle_flush_disk_cache_get()),
    save_info_dict(libtorrent_jni.torrent_handle_save_info_dict_get());

    public final int swigValue() {
      return swigValue;
    }

    public static save_resume_flags_t swigToEnum(int swigValue) {
      save_resume_flags_t[] swigValues = save_resume_flags_t.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (save_resume_flags_t swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + save_resume_flags_t.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private save_resume_flags_t() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private save_resume_flags_t(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private save_resume_flags_t(save_resume_flags_t swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

}
