/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.frostwire.jlibtorrent.swig;

public class settings_pack extends settings_interface {
  private transient long swigCPtr;

  protected settings_pack(long cPtr, boolean cMemoryOwn) {
    super(libtorrent_jni.settings_pack_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  protected static long getCPtr(settings_pack obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected static long swigRelease(settings_pack obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        libtorrent_jni.delete_settings_pack(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public settings_pack() {
    this(libtorrent_jni.new_settings_pack__SWIG_0(), true);
  }

  public settings_pack(settings_pack arg0) {
    this(libtorrent_jni.new_settings_pack__SWIG_1(settings_pack.getCPtr(arg0), arg0), true);
  }

  public void set_str(int name, String val) {
    libtorrent_jni.settings_pack_set_str(swigCPtr, this, name, val);
  }

  public void set_int(int name, int val) {
    libtorrent_jni.settings_pack_set_int(swigCPtr, this, name, val);
  }

  public void set_bool(int name, boolean val) {
    libtorrent_jni.settings_pack_set_bool(swigCPtr, this, name, val);
  }

  public boolean has_val(int name) {
    return libtorrent_jni.settings_pack_has_val(swigCPtr, this, name);
  }

  public void clear() {
    libtorrent_jni.settings_pack_clear__SWIG_0(swigCPtr, this);
  }

  public void clear(int name) {
    libtorrent_jni.settings_pack_clear__SWIG_1(swigCPtr, this, name);
  }

  public String get_str(int name) {
    return libtorrent_jni.settings_pack_get_str(swigCPtr, this, name);
  }

  public int get_int(int name) {
    return libtorrent_jni.settings_pack_get_int(swigCPtr, this, name);
  }

  public boolean get_bool(int name) {
    return libtorrent_jni.settings_pack_get_bool(swigCPtr, this, name);
  }

  public byte_vector get_bytes(int name) {
    return new byte_vector(libtorrent_jni.settings_pack_get_bytes(swigCPtr, this, name), true);
  }

  public void set_bytes(int name, byte_vector v) {
    libtorrent_jni.settings_pack_set_bytes(swigCPtr, this, name, byte_vector.getCPtr(v), v);
  }

  public final static class type_bases {
    public final static settings_pack.type_bases string_type_base = new settings_pack.type_bases("string_type_base", libtorrent_jni.settings_pack_string_type_base_get());
    public final static settings_pack.type_bases int_type_base = new settings_pack.type_bases("int_type_base", libtorrent_jni.settings_pack_int_type_base_get());
    public final static settings_pack.type_bases bool_type_base = new settings_pack.type_bases("bool_type_base", libtorrent_jni.settings_pack_bool_type_base_get());
    public final static settings_pack.type_bases type_mask = new settings_pack.type_bases("type_mask", libtorrent_jni.settings_pack_type_mask_get());
    public final static settings_pack.type_bases index_mask = new settings_pack.type_bases("index_mask", libtorrent_jni.settings_pack_index_mask_get());

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static type_bases swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + type_bases.class + " with value " + swigValue);
    }

    private type_bases(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private type_bases(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private type_bases(String swigName, type_bases swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static type_bases[] swigValues = { string_type_base, int_type_base, bool_type_base, type_mask, index_mask };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static class string_types {
    public final static settings_pack.string_types user_agent = new settings_pack.string_types("user_agent", libtorrent_jni.settings_pack_user_agent_get());
    public final static settings_pack.string_types announce_ip = new settings_pack.string_types("announce_ip");
    public final static settings_pack.string_types handshake_client_version = new settings_pack.string_types("handshake_client_version", libtorrent_jni.settings_pack_handshake_client_version_get());
    public final static settings_pack.string_types outgoing_interfaces = new settings_pack.string_types("outgoing_interfaces");
    public final static settings_pack.string_types listen_interfaces = new settings_pack.string_types("listen_interfaces");
    public final static settings_pack.string_types proxy_hostname = new settings_pack.string_types("proxy_hostname");
    public final static settings_pack.string_types proxy_username = new settings_pack.string_types("proxy_username");
    public final static settings_pack.string_types proxy_password = new settings_pack.string_types("proxy_password");
    public final static settings_pack.string_types i2p_hostname = new settings_pack.string_types("i2p_hostname");
    public final static settings_pack.string_types peer_fingerprint = new settings_pack.string_types("peer_fingerprint");
    public final static settings_pack.string_types dht_bootstrap_nodes = new settings_pack.string_types("dht_bootstrap_nodes");
    public final static settings_pack.string_types max_string_setting_internal = new settings_pack.string_types("max_string_setting_internal");

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static string_types swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + string_types.class + " with value " + swigValue);
    }

    private string_types(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private string_types(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private string_types(String swigName, string_types swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static string_types[] swigValues = { user_agent, announce_ip, handshake_client_version, outgoing_interfaces, listen_interfaces, proxy_hostname, proxy_username, proxy_password, i2p_hostname, peer_fingerprint, dht_bootstrap_nodes, max_string_setting_internal };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static class bool_types {
    public final static settings_pack.bool_types allow_multiple_connections_per_ip = new settings_pack.bool_types("allow_multiple_connections_per_ip", libtorrent_jni.settings_pack_allow_multiple_connections_per_ip_get());
    public final static settings_pack.bool_types send_redundant_have = new settings_pack.bool_types("send_redundant_have", libtorrent_jni.settings_pack_send_redundant_have_get());
    public final static settings_pack.bool_types use_dht_as_fallback = new settings_pack.bool_types("use_dht_as_fallback", libtorrent_jni.settings_pack_use_dht_as_fallback_get());
    public final static settings_pack.bool_types upnp_ignore_nonrouters = new settings_pack.bool_types("upnp_ignore_nonrouters");
    public final static settings_pack.bool_types use_parole_mode = new settings_pack.bool_types("use_parole_mode");
    public final static settings_pack.bool_types auto_manage_prefer_seeds = new settings_pack.bool_types("auto_manage_prefer_seeds", libtorrent_jni.settings_pack_auto_manage_prefer_seeds_get());
    public final static settings_pack.bool_types dont_count_slow_torrents = new settings_pack.bool_types("dont_count_slow_torrents");
    public final static settings_pack.bool_types close_redundant_connections = new settings_pack.bool_types("close_redundant_connections");
    public final static settings_pack.bool_types prioritize_partial_pieces = new settings_pack.bool_types("prioritize_partial_pieces");
    public final static settings_pack.bool_types rate_limit_ip_overhead = new settings_pack.bool_types("rate_limit_ip_overhead");
    public final static settings_pack.bool_types announce_to_all_tiers = new settings_pack.bool_types("announce_to_all_tiers");
    public final static settings_pack.bool_types announce_to_all_trackers = new settings_pack.bool_types("announce_to_all_trackers");
    public final static settings_pack.bool_types prefer_udp_trackers = new settings_pack.bool_types("prefer_udp_trackers");
    public final static settings_pack.bool_types disable_hash_checks = new settings_pack.bool_types("disable_hash_checks", libtorrent_jni.settings_pack_disable_hash_checks_get());
    public final static settings_pack.bool_types allow_i2p_mixed = new settings_pack.bool_types("allow_i2p_mixed");
    public final static settings_pack.bool_types no_atime_storage = new settings_pack.bool_types("no_atime_storage", libtorrent_jni.settings_pack_no_atime_storage_get());
    public final static settings_pack.bool_types incoming_starts_queued_torrents = new settings_pack.bool_types("incoming_starts_queued_torrents");
    public final static settings_pack.bool_types report_true_downloaded = new settings_pack.bool_types("report_true_downloaded");
    public final static settings_pack.bool_types strict_end_game_mode = new settings_pack.bool_types("strict_end_game_mode");
    public final static settings_pack.bool_types enable_outgoing_utp = new settings_pack.bool_types("enable_outgoing_utp", libtorrent_jni.settings_pack_enable_outgoing_utp_get());
    public final static settings_pack.bool_types enable_incoming_utp = new settings_pack.bool_types("enable_incoming_utp");
    public final static settings_pack.bool_types enable_outgoing_tcp = new settings_pack.bool_types("enable_outgoing_tcp");
    public final static settings_pack.bool_types enable_incoming_tcp = new settings_pack.bool_types("enable_incoming_tcp");
    public final static settings_pack.bool_types no_recheck_incomplete_resume = new settings_pack.bool_types("no_recheck_incomplete_resume", libtorrent_jni.settings_pack_no_recheck_incomplete_resume_get());
    public final static settings_pack.bool_types anonymous_mode = new settings_pack.bool_types("anonymous_mode");
    public final static settings_pack.bool_types report_web_seed_downloads = new settings_pack.bool_types("report_web_seed_downloads");
    public final static settings_pack.bool_types seeding_outgoing_connections = new settings_pack.bool_types("seeding_outgoing_connections", libtorrent_jni.settings_pack_seeding_outgoing_connections_get());
    public final static settings_pack.bool_types no_connect_privileged_ports = new settings_pack.bool_types("no_connect_privileged_ports");
    public final static settings_pack.bool_types smooth_connects = new settings_pack.bool_types("smooth_connects");
    public final static settings_pack.bool_types always_send_user_agent = new settings_pack.bool_types("always_send_user_agent");
    public final static settings_pack.bool_types apply_ip_filter_to_trackers = new settings_pack.bool_types("apply_ip_filter_to_trackers");
    public final static settings_pack.bool_types ban_web_seeds = new settings_pack.bool_types("ban_web_seeds", libtorrent_jni.settings_pack_ban_web_seeds_get());
    public final static settings_pack.bool_types support_share_mode = new settings_pack.bool_types("support_share_mode", libtorrent_jni.settings_pack_support_share_mode_get());
    public final static settings_pack.bool_types report_redundant_bytes = new settings_pack.bool_types("report_redundant_bytes", libtorrent_jni.settings_pack_report_redundant_bytes_get());
    public final static settings_pack.bool_types listen_system_port_fallback = new settings_pack.bool_types("listen_system_port_fallback");
    public final static settings_pack.bool_types announce_crypto_support = new settings_pack.bool_types("announce_crypto_support", libtorrent_jni.settings_pack_announce_crypto_support_get());
    public final static settings_pack.bool_types enable_upnp = new settings_pack.bool_types("enable_upnp");
    public final static settings_pack.bool_types enable_natpmp = new settings_pack.bool_types("enable_natpmp");
    public final static settings_pack.bool_types enable_lsd = new settings_pack.bool_types("enable_lsd");
    public final static settings_pack.bool_types enable_dht = new settings_pack.bool_types("enable_dht");
    public final static settings_pack.bool_types prefer_rc4 = new settings_pack.bool_types("prefer_rc4");
    public final static settings_pack.bool_types proxy_hostnames = new settings_pack.bool_types("proxy_hostnames");
    public final static settings_pack.bool_types proxy_peer_connections = new settings_pack.bool_types("proxy_peer_connections");
    public final static settings_pack.bool_types auto_sequential = new settings_pack.bool_types("auto_sequential");
    public final static settings_pack.bool_types proxy_tracker_connections = new settings_pack.bool_types("proxy_tracker_connections");
    public final static settings_pack.bool_types enable_ip_notifier = new settings_pack.bool_types("enable_ip_notifier");
    public final static settings_pack.bool_types dht_prefer_verified_node_ids = new settings_pack.bool_types("dht_prefer_verified_node_ids");
    public final static settings_pack.bool_types dht_restrict_routing_ips = new settings_pack.bool_types("dht_restrict_routing_ips");
    public final static settings_pack.bool_types dht_restrict_search_ips = new settings_pack.bool_types("dht_restrict_search_ips");
    public final static settings_pack.bool_types dht_extended_routing_table = new settings_pack.bool_types("dht_extended_routing_table");
    public final static settings_pack.bool_types dht_aggressive_lookups = new settings_pack.bool_types("dht_aggressive_lookups");
    public final static settings_pack.bool_types dht_privacy_lookups = new settings_pack.bool_types("dht_privacy_lookups");
    public final static settings_pack.bool_types dht_enforce_node_id = new settings_pack.bool_types("dht_enforce_node_id");
    public final static settings_pack.bool_types dht_ignore_dark_internet = new settings_pack.bool_types("dht_ignore_dark_internet");
    public final static settings_pack.bool_types dht_read_only = new settings_pack.bool_types("dht_read_only");
    public final static settings_pack.bool_types piece_extent_affinity = new settings_pack.bool_types("piece_extent_affinity");
    public final static settings_pack.bool_types validate_https_trackers = new settings_pack.bool_types("validate_https_trackers");
    public final static settings_pack.bool_types ssrf_mitigation = new settings_pack.bool_types("ssrf_mitigation");
    public final static settings_pack.bool_types allow_idna = new settings_pack.bool_types("allow_idna");
    public final static settings_pack.bool_types enable_set_file_valid_data = new settings_pack.bool_types("enable_set_file_valid_data");
    public final static settings_pack.bool_types socks5_udp_send_local_ep = new settings_pack.bool_types("socks5_udp_send_local_ep");
    public final static settings_pack.bool_types max_bool_setting_internal = new settings_pack.bool_types("max_bool_setting_internal");

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static bool_types swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + bool_types.class + " with value " + swigValue);
    }

    private bool_types(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private bool_types(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private bool_types(String swigName, bool_types swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static bool_types[] swigValues = { allow_multiple_connections_per_ip, send_redundant_have, use_dht_as_fallback, upnp_ignore_nonrouters, use_parole_mode, auto_manage_prefer_seeds, dont_count_slow_torrents, close_redundant_connections, prioritize_partial_pieces, rate_limit_ip_overhead, announce_to_all_tiers, announce_to_all_trackers, prefer_udp_trackers, disable_hash_checks, allow_i2p_mixed, no_atime_storage, incoming_starts_queued_torrents, report_true_downloaded, strict_end_game_mode, enable_outgoing_utp, enable_incoming_utp, enable_outgoing_tcp, enable_incoming_tcp, no_recheck_incomplete_resume, anonymous_mode, report_web_seed_downloads, seeding_outgoing_connections, no_connect_privileged_ports, smooth_connects, always_send_user_agent, apply_ip_filter_to_trackers, ban_web_seeds, support_share_mode, report_redundant_bytes, listen_system_port_fallback, announce_crypto_support, enable_upnp, enable_natpmp, enable_lsd, enable_dht, prefer_rc4, proxy_hostnames, proxy_peer_connections, auto_sequential, proxy_tracker_connections, enable_ip_notifier, dht_prefer_verified_node_ids, dht_restrict_routing_ips, dht_restrict_search_ips, dht_extended_routing_table, dht_aggressive_lookups, dht_privacy_lookups, dht_enforce_node_id, dht_ignore_dark_internet, dht_read_only, piece_extent_affinity, validate_https_trackers, ssrf_mitigation, allow_idna, enable_set_file_valid_data, socks5_udp_send_local_ep, max_bool_setting_internal };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static class int_types {
    public final static settings_pack.int_types tracker_completion_timeout = new settings_pack.int_types("tracker_completion_timeout", libtorrent_jni.settings_pack_tracker_completion_timeout_get());
    public final static settings_pack.int_types tracker_receive_timeout = new settings_pack.int_types("tracker_receive_timeout");
    public final static settings_pack.int_types stop_tracker_timeout = new settings_pack.int_types("stop_tracker_timeout");
    public final static settings_pack.int_types tracker_maximum_response_length = new settings_pack.int_types("tracker_maximum_response_length");
    public final static settings_pack.int_types piece_timeout = new settings_pack.int_types("piece_timeout");
    public final static settings_pack.int_types request_timeout = new settings_pack.int_types("request_timeout");
    public final static settings_pack.int_types request_queue_time = new settings_pack.int_types("request_queue_time");
    public final static settings_pack.int_types max_allowed_in_request_queue = new settings_pack.int_types("max_allowed_in_request_queue");
    public final static settings_pack.int_types max_out_request_queue = new settings_pack.int_types("max_out_request_queue");
    public final static settings_pack.int_types whole_pieces_threshold = new settings_pack.int_types("whole_pieces_threshold");
    public final static settings_pack.int_types peer_timeout = new settings_pack.int_types("peer_timeout");
    public final static settings_pack.int_types urlseed_timeout = new settings_pack.int_types("urlseed_timeout");
    public final static settings_pack.int_types urlseed_pipeline_size = new settings_pack.int_types("urlseed_pipeline_size");
    public final static settings_pack.int_types urlseed_wait_retry = new settings_pack.int_types("urlseed_wait_retry");
    public final static settings_pack.int_types file_pool_size = new settings_pack.int_types("file_pool_size");
    public final static settings_pack.int_types max_failcount = new settings_pack.int_types("max_failcount");
    public final static settings_pack.int_types min_reconnect_time = new settings_pack.int_types("min_reconnect_time");
    public final static settings_pack.int_types peer_connect_timeout = new settings_pack.int_types("peer_connect_timeout");
    public final static settings_pack.int_types connection_speed = new settings_pack.int_types("connection_speed");
    public final static settings_pack.int_types inactivity_timeout = new settings_pack.int_types("inactivity_timeout");
    public final static settings_pack.int_types unchoke_interval = new settings_pack.int_types("unchoke_interval");
    public final static settings_pack.int_types optimistic_unchoke_interval = new settings_pack.int_types("optimistic_unchoke_interval");
    public final static settings_pack.int_types num_want = new settings_pack.int_types("num_want");
    public final static settings_pack.int_types initial_picker_threshold = new settings_pack.int_types("initial_picker_threshold");
    public final static settings_pack.int_types allowed_fast_set_size = new settings_pack.int_types("allowed_fast_set_size");
    public final static settings_pack.int_types suggest_mode = new settings_pack.int_types("suggest_mode");
    public final static settings_pack.int_types max_queued_disk_bytes = new settings_pack.int_types("max_queued_disk_bytes");
    public final static settings_pack.int_types handshake_timeout = new settings_pack.int_types("handshake_timeout");
    public final static settings_pack.int_types send_buffer_low_watermark = new settings_pack.int_types("send_buffer_low_watermark");
    public final static settings_pack.int_types send_buffer_watermark = new settings_pack.int_types("send_buffer_watermark");
    public final static settings_pack.int_types send_buffer_watermark_factor = new settings_pack.int_types("send_buffer_watermark_factor");
    public final static settings_pack.int_types choking_algorithm = new settings_pack.int_types("choking_algorithm");
    public final static settings_pack.int_types seed_choking_algorithm = new settings_pack.int_types("seed_choking_algorithm");
    public final static settings_pack.int_types disk_io_write_mode = new settings_pack.int_types("disk_io_write_mode", libtorrent_jni.settings_pack_disk_io_write_mode_get());
    public final static settings_pack.int_types disk_io_read_mode = new settings_pack.int_types("disk_io_read_mode");
    public final static settings_pack.int_types outgoing_port = new settings_pack.int_types("outgoing_port");
    public final static settings_pack.int_types num_outgoing_ports = new settings_pack.int_types("num_outgoing_ports");
    public final static settings_pack.int_types peer_dscp = new settings_pack.int_types("peer_dscp");
    public final static settings_pack.int_types active_downloads = new settings_pack.int_types("active_downloads", libtorrent_jni.settings_pack_active_downloads_get());
    public final static settings_pack.int_types active_seeds = new settings_pack.int_types("active_seeds");
    public final static settings_pack.int_types active_checking = new settings_pack.int_types("active_checking");
    public final static settings_pack.int_types active_dht_limit = new settings_pack.int_types("active_dht_limit");
    public final static settings_pack.int_types active_tracker_limit = new settings_pack.int_types("active_tracker_limit");
    public final static settings_pack.int_types active_lsd_limit = new settings_pack.int_types("active_lsd_limit");
    public final static settings_pack.int_types active_limit = new settings_pack.int_types("active_limit");
    public final static settings_pack.int_types auto_manage_interval = new settings_pack.int_types("auto_manage_interval", libtorrent_jni.settings_pack_auto_manage_interval_get());
    public final static settings_pack.int_types seed_time_limit = new settings_pack.int_types("seed_time_limit");
    public final static settings_pack.int_types auto_scrape_interval = new settings_pack.int_types("auto_scrape_interval");
    public final static settings_pack.int_types auto_scrape_min_interval = new settings_pack.int_types("auto_scrape_min_interval");
    public final static settings_pack.int_types max_peerlist_size = new settings_pack.int_types("max_peerlist_size");
    public final static settings_pack.int_types max_paused_peerlist_size = new settings_pack.int_types("max_paused_peerlist_size");
    public final static settings_pack.int_types min_announce_interval = new settings_pack.int_types("min_announce_interval");
    public final static settings_pack.int_types auto_manage_startup = new settings_pack.int_types("auto_manage_startup");
    public final static settings_pack.int_types seeding_piece_quota = new settings_pack.int_types("seeding_piece_quota");
    public final static settings_pack.int_types max_rejects = new settings_pack.int_types("max_rejects");
    public final static settings_pack.int_types recv_socket_buffer_size = new settings_pack.int_types("recv_socket_buffer_size");
    public final static settings_pack.int_types send_socket_buffer_size = new settings_pack.int_types("send_socket_buffer_size");
    public final static settings_pack.int_types max_peer_recv_buffer_size = new settings_pack.int_types("max_peer_recv_buffer_size");
    public final static settings_pack.int_types optimistic_disk_retry = new settings_pack.int_types("optimistic_disk_retry", libtorrent_jni.settings_pack_optimistic_disk_retry_get());
    public final static settings_pack.int_types max_suggest_pieces = new settings_pack.int_types("max_suggest_pieces");
    public final static settings_pack.int_types local_service_announce_interval = new settings_pack.int_types("local_service_announce_interval");
    public final static settings_pack.int_types dht_announce_interval = new settings_pack.int_types("dht_announce_interval");
    public final static settings_pack.int_types udp_tracker_token_expiry = new settings_pack.int_types("udp_tracker_token_expiry");
    public final static settings_pack.int_types num_optimistic_unchoke_slots = new settings_pack.int_types("num_optimistic_unchoke_slots", libtorrent_jni.settings_pack_num_optimistic_unchoke_slots_get());
    public final static settings_pack.int_types max_pex_peers = new settings_pack.int_types("max_pex_peers", libtorrent_jni.settings_pack_max_pex_peers_get());
    public final static settings_pack.int_types tick_interval = new settings_pack.int_types("tick_interval");
    public final static settings_pack.int_types share_mode_target = new settings_pack.int_types("share_mode_target");
    public final static settings_pack.int_types upload_rate_limit = new settings_pack.int_types("upload_rate_limit");
    public final static settings_pack.int_types download_rate_limit = new settings_pack.int_types("download_rate_limit");
    public final static settings_pack.int_types dht_upload_rate_limit = new settings_pack.int_types("dht_upload_rate_limit", libtorrent_jni.settings_pack_dht_upload_rate_limit_get());
    public final static settings_pack.int_types unchoke_slots_limit = new settings_pack.int_types("unchoke_slots_limit");
    public final static settings_pack.int_types connections_limit = new settings_pack.int_types("connections_limit", libtorrent_jni.settings_pack_connections_limit_get());
    public final static settings_pack.int_types connections_slack = new settings_pack.int_types("connections_slack");
    public final static settings_pack.int_types utp_target_delay = new settings_pack.int_types("utp_target_delay");
    public final static settings_pack.int_types utp_gain_factor = new settings_pack.int_types("utp_gain_factor");
    public final static settings_pack.int_types utp_min_timeout = new settings_pack.int_types("utp_min_timeout");
    public final static settings_pack.int_types utp_syn_resends = new settings_pack.int_types("utp_syn_resends");
    public final static settings_pack.int_types utp_fin_resends = new settings_pack.int_types("utp_fin_resends");
    public final static settings_pack.int_types utp_num_resends = new settings_pack.int_types("utp_num_resends");
    public final static settings_pack.int_types utp_connect_timeout = new settings_pack.int_types("utp_connect_timeout");
    public final static settings_pack.int_types utp_loss_multiplier = new settings_pack.int_types("utp_loss_multiplier", libtorrent_jni.settings_pack_utp_loss_multiplier_get());
    public final static settings_pack.int_types mixed_mode_algorithm = new settings_pack.int_types("mixed_mode_algorithm");
    public final static settings_pack.int_types listen_queue_size = new settings_pack.int_types("listen_queue_size");
    public final static settings_pack.int_types torrent_connect_boost = new settings_pack.int_types("torrent_connect_boost");
    public final static settings_pack.int_types alert_queue_size = new settings_pack.int_types("alert_queue_size");
    public final static settings_pack.int_types max_metadata_size = new settings_pack.int_types("max_metadata_size");
    public final static settings_pack.int_types hashing_threads = new settings_pack.int_types("hashing_threads");
    public final static settings_pack.int_types checking_mem_usage = new settings_pack.int_types("checking_mem_usage");
    public final static settings_pack.int_types predictive_piece_announce = new settings_pack.int_types("predictive_piece_announce");
    public final static settings_pack.int_types aio_threads = new settings_pack.int_types("aio_threads");
    public final static settings_pack.int_types tracker_backoff = new settings_pack.int_types("tracker_backoff", libtorrent_jni.settings_pack_tracker_backoff_get());
    public final static settings_pack.int_types share_ratio_limit = new settings_pack.int_types("share_ratio_limit");
    public final static settings_pack.int_types seed_time_ratio_limit = new settings_pack.int_types("seed_time_ratio_limit");
    public final static settings_pack.int_types peer_turnover = new settings_pack.int_types("peer_turnover");
    public final static settings_pack.int_types peer_turnover_cutoff = new settings_pack.int_types("peer_turnover_cutoff");
    public final static settings_pack.int_types peer_turnover_interval = new settings_pack.int_types("peer_turnover_interval");
    public final static settings_pack.int_types connect_seed_every_n_download = new settings_pack.int_types("connect_seed_every_n_download");
    public final static settings_pack.int_types max_http_recv_buffer_size = new settings_pack.int_types("max_http_recv_buffer_size");
    public final static settings_pack.int_types max_retry_port_bind = new settings_pack.int_types("max_retry_port_bind");
    public final static settings_pack.int_types alert_mask = new settings_pack.int_types("alert_mask");
    public final static settings_pack.int_types out_enc_policy = new settings_pack.int_types("out_enc_policy");
    public final static settings_pack.int_types in_enc_policy = new settings_pack.int_types("in_enc_policy");
    public final static settings_pack.int_types allowed_enc_level = new settings_pack.int_types("allowed_enc_level");
    public final static settings_pack.int_types inactive_down_rate = new settings_pack.int_types("inactive_down_rate");
    public final static settings_pack.int_types inactive_up_rate = new settings_pack.int_types("inactive_up_rate");
    public final static settings_pack.int_types proxy_type = new settings_pack.int_types("proxy_type");
    public final static settings_pack.int_types proxy_port = new settings_pack.int_types("proxy_port");
    public final static settings_pack.int_types i2p_port = new settings_pack.int_types("i2p_port");
    public final static settings_pack.int_types urlseed_max_request_bytes = new settings_pack.int_types("urlseed_max_request_bytes", libtorrent_jni.settings_pack_urlseed_max_request_bytes_get());
    public final static settings_pack.int_types web_seed_name_lookup_retry = new settings_pack.int_types("web_seed_name_lookup_retry");
    public final static settings_pack.int_types close_file_interval = new settings_pack.int_types("close_file_interval");
    public final static settings_pack.int_types utp_cwnd_reduce_timer = new settings_pack.int_types("utp_cwnd_reduce_timer");
    public final static settings_pack.int_types max_web_seed_connections = new settings_pack.int_types("max_web_seed_connections");
    public final static settings_pack.int_types resolver_cache_timeout = new settings_pack.int_types("resolver_cache_timeout");
    public final static settings_pack.int_types send_not_sent_low_watermark = new settings_pack.int_types("send_not_sent_low_watermark");
    public final static settings_pack.int_types rate_choker_initial_threshold = new settings_pack.int_types("rate_choker_initial_threshold");
    public final static settings_pack.int_types upnp_lease_duration = new settings_pack.int_types("upnp_lease_duration");
    public final static settings_pack.int_types max_concurrent_http_announces = new settings_pack.int_types("max_concurrent_http_announces");
    public final static settings_pack.int_types dht_max_peers_reply = new settings_pack.int_types("dht_max_peers_reply");
    public final static settings_pack.int_types dht_search_branching = new settings_pack.int_types("dht_search_branching");
    public final static settings_pack.int_types dht_max_fail_count = new settings_pack.int_types("dht_max_fail_count");
    public final static settings_pack.int_types dht_max_torrents = new settings_pack.int_types("dht_max_torrents");
    public final static settings_pack.int_types dht_max_dht_items = new settings_pack.int_types("dht_max_dht_items");
    public final static settings_pack.int_types dht_max_peers = new settings_pack.int_types("dht_max_peers");
    public final static settings_pack.int_types dht_max_torrent_search_reply = new settings_pack.int_types("dht_max_torrent_search_reply");
    public final static settings_pack.int_types dht_block_timeout = new settings_pack.int_types("dht_block_timeout");
    public final static settings_pack.int_types dht_block_ratelimit = new settings_pack.int_types("dht_block_ratelimit");
    public final static settings_pack.int_types dht_item_lifetime = new settings_pack.int_types("dht_item_lifetime");
    public final static settings_pack.int_types dht_sample_infohashes_interval = new settings_pack.int_types("dht_sample_infohashes_interval");
    public final static settings_pack.int_types dht_max_infohashes_sample_count = new settings_pack.int_types("dht_max_infohashes_sample_count");
    public final static settings_pack.int_types max_piece_count = new settings_pack.int_types("max_piece_count");
    public final static settings_pack.int_types metadata_token_limit = new settings_pack.int_types("metadata_token_limit");
    public final static settings_pack.int_types disk_write_mode = new settings_pack.int_types("disk_write_mode");
    public final static settings_pack.int_types mmap_file_size_cutoff = new settings_pack.int_types("mmap_file_size_cutoff");
    public final static settings_pack.int_types i2p_inbound_quantity = new settings_pack.int_types("i2p_inbound_quantity");
    public final static settings_pack.int_types i2p_outbound_quantity = new settings_pack.int_types("i2p_outbound_quantity");
    public final static settings_pack.int_types i2p_inbound_length = new settings_pack.int_types("i2p_inbound_length");
    public final static settings_pack.int_types i2p_outbound_length = new settings_pack.int_types("i2p_outbound_length");
    public final static settings_pack.int_types announce_port = new settings_pack.int_types("announce_port");
    public final static settings_pack.int_types max_int_setting_internal = new settings_pack.int_types("max_int_setting_internal");

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static int_types swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + int_types.class + " with value " + swigValue);
    }

    private int_types(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private int_types(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private int_types(String swigName, int_types swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static int_types[] swigValues = { tracker_completion_timeout, tracker_receive_timeout, stop_tracker_timeout, tracker_maximum_response_length, piece_timeout, request_timeout, request_queue_time, max_allowed_in_request_queue, max_out_request_queue, whole_pieces_threshold, peer_timeout, urlseed_timeout, urlseed_pipeline_size, urlseed_wait_retry, file_pool_size, max_failcount, min_reconnect_time, peer_connect_timeout, connection_speed, inactivity_timeout, unchoke_interval, optimistic_unchoke_interval, num_want, initial_picker_threshold, allowed_fast_set_size, suggest_mode, max_queued_disk_bytes, handshake_timeout, send_buffer_low_watermark, send_buffer_watermark, send_buffer_watermark_factor, choking_algorithm, seed_choking_algorithm, disk_io_write_mode, disk_io_read_mode, outgoing_port, num_outgoing_ports, peer_dscp, active_downloads, active_seeds, active_checking, active_dht_limit, active_tracker_limit, active_lsd_limit, active_limit, auto_manage_interval, seed_time_limit, auto_scrape_interval, auto_scrape_min_interval, max_peerlist_size, max_paused_peerlist_size, min_announce_interval, auto_manage_startup, seeding_piece_quota, max_rejects, recv_socket_buffer_size, send_socket_buffer_size, max_peer_recv_buffer_size, optimistic_disk_retry, max_suggest_pieces, local_service_announce_interval, dht_announce_interval, udp_tracker_token_expiry, num_optimistic_unchoke_slots, max_pex_peers, tick_interval, share_mode_target, upload_rate_limit, download_rate_limit, dht_upload_rate_limit, unchoke_slots_limit, connections_limit, connections_slack, utp_target_delay, utp_gain_factor, utp_min_timeout, utp_syn_resends, utp_fin_resends, utp_num_resends, utp_connect_timeout, utp_loss_multiplier, mixed_mode_algorithm, listen_queue_size, torrent_connect_boost, alert_queue_size, max_metadata_size, hashing_threads, checking_mem_usage, predictive_piece_announce, aio_threads, tracker_backoff, share_ratio_limit, seed_time_ratio_limit, peer_turnover, peer_turnover_cutoff, peer_turnover_interval, connect_seed_every_n_download, max_http_recv_buffer_size, max_retry_port_bind, alert_mask, out_enc_policy, in_enc_policy, allowed_enc_level, inactive_down_rate, inactive_up_rate, proxy_type, proxy_port, i2p_port, urlseed_max_request_bytes, web_seed_name_lookup_retry, close_file_interval, utp_cwnd_reduce_timer, max_web_seed_connections, resolver_cache_timeout, send_not_sent_low_watermark, rate_choker_initial_threshold, upnp_lease_duration, max_concurrent_http_announces, dht_max_peers_reply, dht_search_branching, dht_max_fail_count, dht_max_torrents, dht_max_dht_items, dht_max_peers, dht_max_torrent_search_reply, dht_block_timeout, dht_block_ratelimit, dht_item_lifetime, dht_sample_infohashes_interval, dht_max_infohashes_sample_count, max_piece_count, metadata_token_limit, disk_write_mode, mmap_file_size_cutoff, i2p_inbound_quantity, i2p_outbound_quantity, i2p_inbound_length, i2p_outbound_length, announce_port, max_int_setting_internal };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static int num_string_settings = libtorrent_jni.settings_pack_num_string_settings_get();
  public final static int num_bool_settings = libtorrent_jni.settings_pack_num_bool_settings_get();
  public final static int num_int_settings = libtorrent_jni.settings_pack_num_int_settings_get();
  public final static class mmap_write_mode_t {
    public final static settings_pack.mmap_write_mode_t always_pwrite = new settings_pack.mmap_write_mode_t("always_pwrite", libtorrent_jni.settings_pack_always_pwrite_get());
    public final static settings_pack.mmap_write_mode_t always_mmap_write = new settings_pack.mmap_write_mode_t("always_mmap_write");
    public final static settings_pack.mmap_write_mode_t auto_mmap_write = new settings_pack.mmap_write_mode_t("auto_mmap_write");

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static mmap_write_mode_t swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + mmap_write_mode_t.class + " with value " + swigValue);
    }

    private mmap_write_mode_t(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private mmap_write_mode_t(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private mmap_write_mode_t(String swigName, mmap_write_mode_t swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static mmap_write_mode_t[] swigValues = { always_pwrite, always_mmap_write, auto_mmap_write };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static class suggest_mode_t {
    public final static settings_pack.suggest_mode_t no_piece_suggestions = new settings_pack.suggest_mode_t("no_piece_suggestions", libtorrent_jni.settings_pack_no_piece_suggestions_get());
    public final static settings_pack.suggest_mode_t suggest_read_cache = new settings_pack.suggest_mode_t("suggest_read_cache", libtorrent_jni.settings_pack_suggest_read_cache_get());

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static suggest_mode_t swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + suggest_mode_t.class + " with value " + swigValue);
    }

    private suggest_mode_t(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private suggest_mode_t(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private suggest_mode_t(String swigName, suggest_mode_t swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static suggest_mode_t[] swigValues = { no_piece_suggestions, suggest_read_cache };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static class choking_algorithm_t {
    public final static settings_pack.choking_algorithm_t fixed_slots_choker = new settings_pack.choking_algorithm_t("fixed_slots_choker", libtorrent_jni.settings_pack_fixed_slots_choker_get());
    public final static settings_pack.choking_algorithm_t rate_based_choker = new settings_pack.choking_algorithm_t("rate_based_choker", libtorrent_jni.settings_pack_rate_based_choker_get());

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static choking_algorithm_t swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + choking_algorithm_t.class + " with value " + swigValue);
    }

    private choking_algorithm_t(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private choking_algorithm_t(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private choking_algorithm_t(String swigName, choking_algorithm_t swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static choking_algorithm_t[] swigValues = { fixed_slots_choker, rate_based_choker };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static class seed_choking_algorithm_t {
    public final static settings_pack.seed_choking_algorithm_t round_robin = new settings_pack.seed_choking_algorithm_t("round_robin");
    public final static settings_pack.seed_choking_algorithm_t fastest_upload = new settings_pack.seed_choking_algorithm_t("fastest_upload");
    public final static settings_pack.seed_choking_algorithm_t anti_leech = new settings_pack.seed_choking_algorithm_t("anti_leech");

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static seed_choking_algorithm_t swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + seed_choking_algorithm_t.class + " with value " + swigValue);
    }

    private seed_choking_algorithm_t(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private seed_choking_algorithm_t(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private seed_choking_algorithm_t(String swigName, seed_choking_algorithm_t swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static seed_choking_algorithm_t[] swigValues = { round_robin, fastest_upload, anti_leech };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static class io_buffer_mode_t {
    public final static settings_pack.io_buffer_mode_t enable_os_cache = new settings_pack.io_buffer_mode_t("enable_os_cache", libtorrent_jni.settings_pack_enable_os_cache_get());
    public final static settings_pack.io_buffer_mode_t disable_os_cache = new settings_pack.io_buffer_mode_t("disable_os_cache", libtorrent_jni.settings_pack_disable_os_cache_get());
    public final static settings_pack.io_buffer_mode_t write_through = new settings_pack.io_buffer_mode_t("write_through", libtorrent_jni.settings_pack_write_through_get());

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static io_buffer_mode_t swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + io_buffer_mode_t.class + " with value " + swigValue);
    }

    private io_buffer_mode_t(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private io_buffer_mode_t(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private io_buffer_mode_t(String swigName, io_buffer_mode_t swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static io_buffer_mode_t[] swigValues = { enable_os_cache, disable_os_cache, write_through };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static class bandwidth_mixed_algo_t {
    public final static settings_pack.bandwidth_mixed_algo_t prefer_tcp = new settings_pack.bandwidth_mixed_algo_t("prefer_tcp", libtorrent_jni.settings_pack_prefer_tcp_get());
    public final static settings_pack.bandwidth_mixed_algo_t peer_proportional = new settings_pack.bandwidth_mixed_algo_t("peer_proportional", libtorrent_jni.settings_pack_peer_proportional_get());

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static bandwidth_mixed_algo_t swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + bandwidth_mixed_algo_t.class + " with value " + swigValue);
    }

    private bandwidth_mixed_algo_t(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private bandwidth_mixed_algo_t(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private bandwidth_mixed_algo_t(String swigName, bandwidth_mixed_algo_t swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static bandwidth_mixed_algo_t[] swigValues = { prefer_tcp, peer_proportional };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static class enc_policy {
    public final static settings_pack.enc_policy pe_forced = new settings_pack.enc_policy("pe_forced");
    public final static settings_pack.enc_policy pe_enabled = new settings_pack.enc_policy("pe_enabled");
    public final static settings_pack.enc_policy pe_disabled = new settings_pack.enc_policy("pe_disabled");

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static enc_policy swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + enc_policy.class + " with value " + swigValue);
    }

    private enc_policy(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private enc_policy(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private enc_policy(String swigName, enc_policy swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static enc_policy[] swigValues = { pe_forced, pe_enabled, pe_disabled };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static class enc_level {
    public final static settings_pack.enc_level pe_plaintext = new settings_pack.enc_level("pe_plaintext", libtorrent_jni.settings_pack_pe_plaintext_get());
    public final static settings_pack.enc_level pe_rc4 = new settings_pack.enc_level("pe_rc4", libtorrent_jni.settings_pack_pe_rc4_get());
    public final static settings_pack.enc_level pe_both = new settings_pack.enc_level("pe_both", libtorrent_jni.settings_pack_pe_both_get());

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static enc_level swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + enc_level.class + " with value " + swigValue);
    }

    private enc_level(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private enc_level(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private enc_level(String swigName, enc_level swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static enc_level[] swigValues = { pe_plaintext, pe_rc4, pe_both };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  public final static class proxy_type_t {
    public final static settings_pack.proxy_type_t none = new settings_pack.proxy_type_t("none");
    public final static settings_pack.proxy_type_t socks4 = new settings_pack.proxy_type_t("socks4");
    public final static settings_pack.proxy_type_t socks5 = new settings_pack.proxy_type_t("socks5");
    public final static settings_pack.proxy_type_t socks5_pw = new settings_pack.proxy_type_t("socks5_pw");
    public final static settings_pack.proxy_type_t http = new settings_pack.proxy_type_t("http");
    public final static settings_pack.proxy_type_t http_pw = new settings_pack.proxy_type_t("http_pw");

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static proxy_type_t swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + proxy_type_t.class + " with value " + swigValue);
    }

    private proxy_type_t(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private proxy_type_t(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private proxy_type_t(String swigName, proxy_type_t swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static proxy_type_t[] swigValues = { none, socks4, socks5, socks5_pw, http, http_pw };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

}
