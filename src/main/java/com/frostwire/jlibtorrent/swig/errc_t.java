/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.frostwire.jlibtorrent.swig;

public final class errc_t {
  public final static errc_t success = new errc_t("success", libtorrent_jni.success_get());
  public final static errc_t address_family_not_supported = new errc_t("address_family_not_supported", libtorrent_jni.address_family_not_supported_get());
  public final static errc_t address_in_use = new errc_t("address_in_use", libtorrent_jni.address_in_use_get());
  public final static errc_t address_not_available = new errc_t("address_not_available", libtorrent_jni.address_not_available_get());
  public final static errc_t already_connected = new errc_t("already_connected", libtorrent_jni.already_connected_get());
  public final static errc_t argument_list_too_long = new errc_t("argument_list_too_long", libtorrent_jni.argument_list_too_long_get());
  public final static errc_t argument_out_of_domain = new errc_t("argument_out_of_domain", libtorrent_jni.argument_out_of_domain_get());
  public final static errc_t bad_address = new errc_t("bad_address", libtorrent_jni.bad_address_get());
  public final static errc_t bad_file_descriptor = new errc_t("bad_file_descriptor", libtorrent_jni.bad_file_descriptor_get());
  public final static errc_t bad_message = new errc_t("bad_message", libtorrent_jni.bad_message_get());
  public final static errc_t broken_pipe = new errc_t("broken_pipe", libtorrent_jni.broken_pipe_get());
  public final static errc_t connection_aborted = new errc_t("connection_aborted", libtorrent_jni.connection_aborted_get());
  public final static errc_t connection_already_in_progress = new errc_t("connection_already_in_progress", libtorrent_jni.connection_already_in_progress_get());
  public final static errc_t connection_refused = new errc_t("connection_refused", libtorrent_jni.connection_refused_get());
  public final static errc_t connection_reset = new errc_t("connection_reset", libtorrent_jni.connection_reset_get());
  public final static errc_t cross_device_link = new errc_t("cross_device_link", libtorrent_jni.cross_device_link_get());
  public final static errc_t destination_address_required = new errc_t("destination_address_required", libtorrent_jni.destination_address_required_get());
  public final static errc_t device_or_resource_busy = new errc_t("device_or_resource_busy", libtorrent_jni.device_or_resource_busy_get());
  public final static errc_t directory_not_empty = new errc_t("directory_not_empty", libtorrent_jni.directory_not_empty_get());
  public final static errc_t executable_format_error = new errc_t("executable_format_error", libtorrent_jni.executable_format_error_get());
  public final static errc_t file_exists = new errc_t("file_exists", libtorrent_jni.file_exists_get());
  public final static errc_t file_too_large = new errc_t("file_too_large", libtorrent_jni.file_too_large_get());
  public final static errc_t filename_too_long = new errc_t("filename_too_long", libtorrent_jni.filename_too_long_get());
  public final static errc_t function_not_supported = new errc_t("function_not_supported", libtorrent_jni.function_not_supported_get());
  public final static errc_t host_unreachable = new errc_t("host_unreachable", libtorrent_jni.host_unreachable_get());
  public final static errc_t identifier_removed = new errc_t("identifier_removed", libtorrent_jni.identifier_removed_get());
  public final static errc_t illegal_byte_sequence = new errc_t("illegal_byte_sequence", libtorrent_jni.illegal_byte_sequence_get());
  public final static errc_t inappropriate_io_control_operation = new errc_t("inappropriate_io_control_operation", libtorrent_jni.inappropriate_io_control_operation_get());
  public final static errc_t interrupted = new errc_t("interrupted", libtorrent_jni.interrupted_get());
  public final static errc_t invalid_argument = new errc_t("invalid_argument", libtorrent_jni.invalid_argument_get());
  public final static errc_t invalid_seek = new errc_t("invalid_seek", libtorrent_jni.invalid_seek_get());
  public final static errc_t io_error = new errc_t("io_error", libtorrent_jni.io_error_get());
  public final static errc_t is_a_directory = new errc_t("is_a_directory", libtorrent_jni.is_a_directory_get());
  public final static errc_t message_size = new errc_t("message_size", libtorrent_jni.message_size_get());
  public final static errc_t network_down = new errc_t("network_down", libtorrent_jni.network_down_get());
  public final static errc_t network_reset = new errc_t("network_reset", libtorrent_jni.network_reset_get());
  public final static errc_t network_unreachable = new errc_t("network_unreachable", libtorrent_jni.network_unreachable_get());
  public final static errc_t no_buffer_space = new errc_t("no_buffer_space", libtorrent_jni.no_buffer_space_get());
  public final static errc_t no_child_process = new errc_t("no_child_process", libtorrent_jni.no_child_process_get());
  public final static errc_t no_link = new errc_t("no_link", libtorrent_jni.no_link_get());
  public final static errc_t no_lock_available = new errc_t("no_lock_available", libtorrent_jni.no_lock_available_get());
  public final static errc_t no_message_available = new errc_t("no_message_available", libtorrent_jni.no_message_available_get());
  public final static errc_t no_message = new errc_t("no_message", libtorrent_jni.no_message_get());
  public final static errc_t no_protocol_option = new errc_t("no_protocol_option", libtorrent_jni.no_protocol_option_get());
  public final static errc_t no_space_on_device = new errc_t("no_space_on_device", libtorrent_jni.no_space_on_device_get());
  public final static errc_t no_stream_resources = new errc_t("no_stream_resources", libtorrent_jni.no_stream_resources_get());
  public final static errc_t no_such_device_or_address = new errc_t("no_such_device_or_address", libtorrent_jni.no_such_device_or_address_get());
  public final static errc_t no_such_device = new errc_t("no_such_device", libtorrent_jni.no_such_device_get());
  public final static errc_t no_such_file_or_directory = new errc_t("no_such_file_or_directory", libtorrent_jni.no_such_file_or_directory_get());
  public final static errc_t no_such_process = new errc_t("no_such_process", libtorrent_jni.no_such_process_get());
  public final static errc_t not_a_directory = new errc_t("not_a_directory", libtorrent_jni.not_a_directory_get());
  public final static errc_t not_a_socket = new errc_t("not_a_socket", libtorrent_jni.not_a_socket_get());
  public final static errc_t not_a_stream = new errc_t("not_a_stream", libtorrent_jni.not_a_stream_get());
  public final static errc_t not_connected = new errc_t("not_connected", libtorrent_jni.not_connected_get());
  public final static errc_t not_enough_memory = new errc_t("not_enough_memory", libtorrent_jni.not_enough_memory_get());
  public final static errc_t not_supported = new errc_t("not_supported", libtorrent_jni.not_supported_get());
  public final static errc_t operation_canceled = new errc_t("operation_canceled", libtorrent_jni.operation_canceled_get());
  public final static errc_t operation_in_progress = new errc_t("operation_in_progress", libtorrent_jni.operation_in_progress_get());
  public final static errc_t operation_not_permitted = new errc_t("operation_not_permitted", libtorrent_jni.operation_not_permitted_get());
  public final static errc_t operation_not_supported = new errc_t("operation_not_supported", libtorrent_jni.operation_not_supported_get());
  public final static errc_t operation_would_block = new errc_t("operation_would_block", libtorrent_jni.operation_would_block_get());
  public final static errc_t owner_dead = new errc_t("owner_dead", libtorrent_jni.owner_dead_get());
  public final static errc_t permission_denied = new errc_t("permission_denied", libtorrent_jni.permission_denied_get());
  public final static errc_t protocol_error = new errc_t("protocol_error", libtorrent_jni.protocol_error_get());
  public final static errc_t protocol_not_supported = new errc_t("protocol_not_supported", libtorrent_jni.protocol_not_supported_get());
  public final static errc_t read_only_file_system = new errc_t("read_only_file_system", libtorrent_jni.read_only_file_system_get());
  public final static errc_t resource_deadlock_would_occur = new errc_t("resource_deadlock_would_occur", libtorrent_jni.resource_deadlock_would_occur_get());
  public final static errc_t resource_unavailable_try_again = new errc_t("resource_unavailable_try_again", libtorrent_jni.resource_unavailable_try_again_get());
  public final static errc_t result_out_of_range = new errc_t("result_out_of_range", libtorrent_jni.result_out_of_range_get());
  public final static errc_t state_not_recoverable = new errc_t("state_not_recoverable", libtorrent_jni.state_not_recoverable_get());
  public final static errc_t stream_timeout = new errc_t("stream_timeout", libtorrent_jni.stream_timeout_get());
  public final static errc_t text_file_busy = new errc_t("text_file_busy", libtorrent_jni.text_file_busy_get());
  public final static errc_t timed_out = new errc_t("timed_out", libtorrent_jni.timed_out_get());
  public final static errc_t too_many_files_open_in_system = new errc_t("too_many_files_open_in_system", libtorrent_jni.too_many_files_open_in_system_get());
  public final static errc_t too_many_files_open = new errc_t("too_many_files_open", libtorrent_jni.too_many_files_open_get());
  public final static errc_t too_many_links = new errc_t("too_many_links", libtorrent_jni.too_many_links_get());
  public final static errc_t too_many_symbolic_link_levels = new errc_t("too_many_symbolic_link_levels", libtorrent_jni.too_many_symbolic_link_levels_get());
  public final static errc_t value_too_large = new errc_t("value_too_large", libtorrent_jni.value_too_large_get());
  public final static errc_t wrong_protocol_type = new errc_t("wrong_protocol_type", libtorrent_jni.wrong_protocol_type_get());

  public final int swigValue() {
    return swigValue;
  }

  public String toString() {
    return swigName;
  }

  public static errc_t swigToEnum(int swigValue) {
    if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
      return swigValues[swigValue];
    for (int i = 0; i < swigValues.length; i++)
      if (swigValues[i].swigValue == swigValue)
        return swigValues[i];
    throw new IllegalArgumentException("No enum " + errc_t.class + " with value " + swigValue);
  }

  private errc_t(String swigName) {
    this.swigName = swigName;
    this.swigValue = swigNext++;
  }

  private errc_t(String swigName, int swigValue) {
    this.swigName = swigName;
    this.swigValue = swigValue;
    swigNext = swigValue+1;
  }

  private errc_t(String swigName, errc_t swigEnum) {
    this.swigName = swigName;
    this.swigValue = swigEnum.swigValue;
    swigNext = this.swigValue+1;
  }

  private static errc_t[] swigValues = { success, address_family_not_supported, address_in_use, address_not_available, already_connected, argument_list_too_long, argument_out_of_domain, bad_address, bad_file_descriptor, bad_message, broken_pipe, connection_aborted, connection_already_in_progress, connection_refused, connection_reset, cross_device_link, destination_address_required, device_or_resource_busy, directory_not_empty, executable_format_error, file_exists, file_too_large, filename_too_long, function_not_supported, host_unreachable, identifier_removed, illegal_byte_sequence, inappropriate_io_control_operation, interrupted, invalid_argument, invalid_seek, io_error, is_a_directory, message_size, network_down, network_reset, network_unreachable, no_buffer_space, no_child_process, no_link, no_lock_available, no_message_available, no_message, no_protocol_option, no_space_on_device, no_stream_resources, no_such_device_or_address, no_such_device, no_such_file_or_directory, no_such_process, not_a_directory, not_a_socket, not_a_stream, not_connected, not_enough_memory, not_supported, operation_canceled, operation_in_progress, operation_not_permitted, operation_not_supported, operation_would_block, owner_dead, permission_denied, protocol_error, protocol_not_supported, read_only_file_system, resource_deadlock_would_occur, resource_unavailable_try_again, result_out_of_range, state_not_recoverable, stream_timeout, text_file_busy, timed_out, too_many_files_open_in_system, too_many_files_open, too_many_links, too_many_symbolic_link_levels, value_too_large, wrong_protocol_type };
  private static int swigNext = 0;
  private final int swigValue;
  private final String swigName;
}

